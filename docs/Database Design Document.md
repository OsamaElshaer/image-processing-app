# **Database Design Document**

## **1. Introduction**

### **1.1 Purpose**

The purpose of this document is to outline the database design for the Image Processing Application. The design is focused on PostgreSQL, which will be used for storing metadata about images, user information, and logs. The database design will facilitate efficient data access, management, and scalability within a microservices architecture.

### **1.2 Scope**

This document will cover the design of the database schema, data models, relationships, data access patterns, and performance considerations. It will also address storage strategies for image data and logs, ensuring high availability, reliability, and performance.

------

## **2. Database Schema Overview**

The database will consist of the following primary entities:

- **Images**: Contains metadata related to each image uploaded by users.
- **Users**: Stores information about the users, including authentication and roles.
- **Logs**: Stores logs generated by different services for monitoring and debugging purposes.

These entities are designed to be highly normalized, ensuring data integrity and efficient querying. PostgreSQL’s relational model will be leveraged for complex queries and transactions.

------

## **3. Data Model**

### **3.1 Images Table**

The **Images** table stores metadata related to the images uploaded by users. This table tracks the state of each image as it undergoes processing.

#### **Table Definition:**

```sql
sqlCopy codeCREATE TABLE images (
    image_id SERIAL PRIMARY KEY,                -- Unique auto-incremented ID for each image
    user_id INT NOT NULL,                       -- Foreign key to the Users table
    file_name VARCHAR(255) NOT NULL,            -- Original file name of the uploaded image
    file_path VARCHAR(512) NOT NULL,            -- Path in the cloud storage where the image is saved
    status VARCHAR(20) NOT NULL,                -- Processing status (e.g., 'pending', 'completed')
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- Timestamp when the image was uploaded
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- Timestamp when the image was last updated
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE  -- Relates to the Users table
);
```

#### **Key Fields:**

- **image_id**: The primary key, uniquely identifies each image in the system.
- **user_id**: A reference to the user who uploaded the image, establishing a relationship between the image and the user.
- **file_name**: The original name of the image file, allowing for reference and potential download.
- **file_path**: The location in cloud storage (e.g., AWS S3) where the image is stored.
- **status**: Represents the processing status of the image, such as ‘pending’, ‘in progress’, or ‘completed’.
- **created_at**: Automatically set when the image is uploaded.
- **updated_at**: Automatically updated when the image’s status is changed.

### **3.2 Users Table**

The **Users** table stores authentication information and user roles.

#### **Table Definition:**

```sql
sqlCopy codeCREATE TABLE users (
    user_id SERIAL PRIMARY KEY,                 -- Unique auto-incremented ID for each user
    email VARCHAR(255) UNIQUE NOT NULL,          -- User’s email address (used for authentication)
    password_hash TEXT NOT NULL,                -- Hashed password for security
    role VARCHAR(20) NOT NULL,                  -- User’s role (e.g., 'admin', 'user')
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Timestamp when the user was created
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP  -- Timestamp when the user was last updated
);
```

#### **Key Fields:**

- **user_id**: The primary key, uniquely identifies each user in the system.
- **email**: Unique identifier for the user, used for login.
- **password_hash**: A securely hashed password for user authentication.
- **role**: The role assigned to the user, used for role-based access control (RBAC).
- **created_at**: The timestamp when the user was first created.
- **updated_at**: The timestamp when the user’s details were last updated.

------

## **4. Relationships**

### **4.1 One-to-Many Relationship (User to Images)**

- A **User** can upload many **Images**, but each **Image** belongs to a single **User**. This relationship is established through the `user_id` foreign key in the **Images** table.
- **On Delete Cascade**: If a user is deleted, all associated images will also be deleted automatically.

------

### **5. Data Access Patterns**

#### **5.1 Common Queries:**

- Fetch image metadata by image ID:

  ```sql
  Copy code
  SELECT * FROM images WHERE image_id = <image_id>;
  ```

- Fetch all images by user ID:

  ```sql
  Copy code
  SELECT * FROM images WHERE user_id = <user_id>;
  ```

- Fetch logs by service name:

  ```sql
  Copy code
  SELECT * FROM logs WHERE service = '<service_name>';
  ```

#### **5.2 Indexing Strategy:**

- Index on `user_id` in the **Images** table

  : This will optimize queries that fetch images by user.

  ```sql
  Copy code
  CREATE INDEX idx_user_id ON images(user_id);
  ```

- Index on `log_id` and `timestamp` in the **Logs** table

  : This will optimize log querying, particularly for recent logs.

  ```sql
  Copy code
  CREATE INDEX idx_log_timestamp ON logs(timestamp);
  ```

## **6. Storage and Performance Considerations**

### **6.1 Storage Strategy**

The system will rely on cloud-based storage for large binary files (images) and PostgreSQL for metadata and logs. The metadata stored in PostgreSQL will include image details like status, user information, and paths to the image files stored in cloud storage (e.g., AWS S3). This separation ensures efficient querying and scalable storage.

- **Images Storage**: Cloud storage (e.g., AWS S3) will be used to store the actual image files. PostgreSQL will store the **file_path** (URL to the image in cloud storage) and related metadata.
- **Logs Storage**: Logs will be retained in the **Logs** table in PostgreSQL. Depending on the volume, we may set up an archiving strategy to move older logs to a more cost-effective storage solution or delete logs after a certain retention period.

### **6.2 Performance Considerations**

- **Indexes**: To ensure optimal performance, indexes will be used on commonly queried fields like `user_id` in the **Images** table and `timestamp` in the **Logs** table. This will improve query performance when fetching images by user or retrieving logs by service.
- **Caching**: For frequently accessed image metadata, a caching layer (e.g., Redis) may be used to reduce database load and improve performance.

### **6.3 Data Retention and Archiving**

- **Images**: Image data stored in cloud storage will be retained as long as the corresponding metadata exists in the database. The images will be deleted if the associated metadata record is removed, either by the user or during data cleanup.
- **Logs**: Logs will be retained for a configurable period, based on business requirements (e.g., 30 days for debugging, 90 days for auditing). After the retention period, logs will either be archived in a cheaper storage or deleted to free up space.

------

## **7. Backup and Recovery Strategy**

### **7.1 Backup Strategy**

Regular backups will be taken to ensure that the database can be restored in case of failure. The following backup strategies will be implemented:

- **Full Backups**: A complete backup of the database will be performed weekly.
- **Incremental Backups**: Daily incremental backups will be taken to capture changes made since the last full backup.

Backups will be stored securely, either in cloud storage or on-premises, depending on the deployment strategy.

------

## **8. Security Considerations**

### **8.1 Data Encryption**

- **In Transit**: All database communications will be encrypted using SSL/TLS to prevent data interception.
- **At Rest**: Sensitive data such as user credentials (passwords) will be stored in a hashed form using a strong hashing algorithm (e.g., bcrypt). If applicable, encrypted fields will be used for sensitive image metadata.

### **8.2 Access Control**

- **Role-based Access Control (RBAC)**: Different roles (e.g., `admin`, `user`) will be assigned to users to restrict access to sensitive data. Admins will have full access to all data, while regular users will only have access to their own images and logs.
- **Database Access**: Access to the database will be limited to authorized application services and personnel, with read/write access granted only as needed.

------

## **9. Monitoring and Auditing**

### **9.1 Database Monitoring**

To ensure the health and performance of the database, the following monitoring mechanisms will be in place:

- **Query Performance**: Monitor slow queries using PostgreSQL’s built-in logging capabilities. Slow queries will be optimized for better performance.
- **Resource Utilization**: CPU, memory, and disk usage will be monitored to ensure that the database can handle the expected load and scale as needed.

### **9.2 Log Auditing**

All significant database actions (e.g., user authentication, image processing status updates) will be logged for auditing purposes. These logs will be stored in the **Logs** table and will be available for review by system administrators.

### **9.3 Automated Alerts**

Automated alerts will be configured for critical events such as:

- **High Latency**: If database queries exceed a defined threshold, alerts will be sent.
- **Disk Space**: Low disk space will trigger alerts to prevent database downtime.
- **Failed Logins**: Multiple failed login attempts will trigger alerts to detect potential security threats.